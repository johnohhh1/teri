name: TERI Model CI/CD Pipeline

on:
  push:
    branches:
      - main
      - develop
      - 'feature/*'
  pull_request:
    branches:
      - main
      - develop
  release:
    types: [published]

env:
  AWS_REGION: us-west-2
  ECR_REPOSITORY_PREFIX: teri-model
  TERRAFORM_VERSION: 1.6.0

jobs:
  # Static Analysis and Security Scanning
  security-scan:
    name: Security and Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Run Checkov static analysis
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: terraform,dockerfile,secrets
          output_format: sarif
          output_file_path: checkov-results.sarif

      - name: Upload Checkov scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: checkov-results.sarif

  # Test API Services
  test-api-services:
    name: Test API Services
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [auth, training, games, progress, notifications, api-gateway]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: services/${{ matrix.service }}/package-lock.json

      - name: Install dependencies
        working-directory: services/${{ matrix.service }}
        run: npm ci

      - name: Run linting
        working-directory: services/${{ matrix.service }}
        run: npm run lint

      - name: Run type checking
        working-directory: services/${{ matrix.service }}
        run: npm run typecheck

      - name: Run unit tests
        working-directory: services/${{ matrix.service }}
        run: npm run test:unit
        env:
          NODE_ENV: test

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        with:
          file: services/${{ matrix.service }}/coverage/lcov.info
          flags: ${{ matrix.service }}
          name: ${{ matrix.service }}-coverage

  # Test ML Services
  test-ml-services:
    name: Test ML Services
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [translator, mediator]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        working-directory: services/${{ matrix.service }}
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Run linting
        working-directory: services/${{ matrix.service }}
        run: |
          flake8 .
          black --check .
          isort --check-only .

      - name: Run type checking
        working-directory: services/${{ matrix.service }}
        run: mypy .

      - name: Run unit tests
        working-directory: services/${{ matrix.service }}
        run: |
          pytest tests/ --cov=. --cov-report=xml --cov-report=html
        env:
          PYTHONPATH: .

      - name: Upload test coverage
        uses: codecov/codecov-action@v3
        with:
          file: services/${{ matrix.service }}/coverage.xml
          flags: ${{ matrix.service }}
          name: ${{ matrix.service }}-coverage

  # Integration Tests
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [test-api-services, test-ml-services]
    services:
      postgres:
        image: postgres:15-alpine
        env:
          POSTGRES_DB: teri_test
          POSTGRES_USER: teri_test
          POSTGRES_PASSWORD: test_password
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Start services with docker-compose
        run: |
          docker-compose -f docker-compose.test.yml up -d --build
          docker-compose -f docker-compose.test.yml ps

      - name: Wait for services to be ready
        run: |
          timeout 300 bash -c 'until curl -f http://localhost:3000/health; do sleep 5; done'
          timeout 300 bash -c 'until curl -f http://localhost:8001/health; do sleep 5; done'

      - name: Run integration tests
        run: |
          npm run test:integration
        env:
          DATABASE_URL: postgresql://teri_test:test_password@localhost:5432/teri_test
          REDIS_URL: redis://localhost:6379
          API_BASE_URL: http://localhost:3000
          TRANSLATOR_URL: http://localhost:8001
          MEDIATOR_URL: http://localhost:8002

      - name: Cleanup
        if: always()
        run: docker-compose -f docker-compose.test.yml down -v

  # Build and Push Docker Images
  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: [security-scan, integration-tests]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop' || github.event_name == 'release'
    strategy:
      matrix:
        include:
          - service: api-gateway
            dockerfile: Dockerfile.api
            context: services/api-gateway
          - service: auth
            dockerfile: Dockerfile.api
            context: services/auth
          - service: training
            dockerfile: Dockerfile.api
            context: services/training
          - service: games
            dockerfile: Dockerfile.api
            context: services/games
          - service: progress
            dockerfile: Dockerfile.api
            context: services/progress
          - service: notifications
            dockerfile: Dockerfile.api
            context: services/notifications
          - service: translator
            dockerfile: Dockerfile.ml
            context: services/translator
          - service: mediator
            dockerfile: Dockerfile.ml
            context: services/mediator

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY_PREFIX }}-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.dockerfile }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          target: production

  # Deploy Infrastructure
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    environment:
      name: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Init
        working-directory: infrastructure/terraform
        run: terraform init
        env:
          TF_VAR_environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'staging' }}

      - name: Terraform Plan
        working-directory: infrastructure/terraform
        run: terraform plan -out=tfplan
        env:
          TF_VAR_environment: ${{ github.ref == 'refs/heads/main' && 'prod' || 'staging' }}
          TF_VAR_domain_name: ${{ secrets.DOMAIN_NAME }}
          TF_VAR_alert_email: ${{ secrets.ALERT_EMAIL }}

      - name: Terraform Apply
        if: github.event_name != 'pull_request'
        working-directory: infrastructure/terraform
        run: terraform apply -auto-approve tfplan

  # Deploy Application
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    environment:
      name: ${{ github.ref == 'refs/heads/main' && 'production' || 'staging' }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to ECS
        run: |
          # Update ECS services with new image tags
          ENVIRONMENT=${{ github.ref == 'refs/heads/main' && 'prod' || 'staging' }}
          CLUSTER_NAME="teri-model-${ENVIRONMENT}-cluster"
          
          # Get the latest image SHA
          IMAGE_TAG="${GITHUB_REF_NAME}-${GITHUB_SHA:0:7}"
          
          # Update each service
          SERVICES=("api-gateway" "auth" "training" "games" "progress" "notifications" "translator" "mediator")
          for SERVICE in "${SERVICES[@]}"; do
            echo "Updating service: $SERVICE"
            aws ecs update-service \
              --cluster "$CLUSTER_NAME" \
              --service "teri-model-${ENVIRONMENT}-${SERVICE}" \
              --force-new-deployment
          done

      - name: Wait for deployment to complete
        run: |
          ENVIRONMENT=${{ github.ref == 'refs/heads/main' && 'prod' || 'staging' }}
          CLUSTER_NAME="teri-model-${ENVIRONMENT}-cluster"
          
          SERVICES=("api-gateway" "auth" "training" "games" "progress" "notifications" "translator" "mediator")
          for SERVICE in "${SERVICES[@]}"; do
            echo "Waiting for service to stabilize: $SERVICE"
            aws ecs wait services-stable \
              --cluster "$CLUSTER_NAME" \
              --services "teri-model-${ENVIRONMENT}-${SERVICE}"
          done

  # Post-deployment tests
  post-deployment-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: [deploy-application]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci
        working-directory: tests/e2e

      - name: Run smoke tests
        run: npm run test:smoke
        working-directory: tests/e2e
        env:
          API_BASE_URL: ${{ github.ref == 'refs/heads/main' && secrets.PROD_API_URL || secrets.STAGING_API_URL }}
          TEST_USER_EMAIL: ${{ secrets.TEST_USER_EMAIL }}
          TEST_USER_PASSWORD: ${{ secrets.TEST_USER_PASSWORD }}

      - name: Run performance tests
        run: npm run test:performance
        working-directory: tests/e2e
        env:
          API_BASE_URL: ${{ github.ref == 'refs/heads/main' && secrets.PROD_API_URL || secrets.STAGING_API_URL }}

  # Notify deployment status
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [post-deployment-tests]
    if: always() && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
    
    steps:
      - name: Notify Slack on success
        if: needs.post-deployment-tests.result == 'success'
        uses: 8398a7/action-slack@v3
        with:
          status: success
          text: '✅ TERI Model deployment succeeded'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on failure
        if: needs.post-deployment-tests.result == 'failure'
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          text: '❌ TERI Model deployment failed'
          webhook_url: ${{ secrets.SLACK_WEBHOOK_URL }}